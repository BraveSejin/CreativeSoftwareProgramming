/*
	'수식으로써 적은' 포인터 변수, 배열, 함수 이름이
	C 컴파일러에 의해 어떻게 deduce될 수 있는지 확인하기 위한 예시들이에요.

	이 파일에서는
	수식으로써 적은 배열 이름이
	해당 배열의 0번째 칸에 대한 포인터 상수 값이 나오는 수식으로 deduce될 수 있음을 확인해 봐요.
*/
 
#include <stdio.h>

/*
	---------------------------------------------------------
	미리 선언 적어 두고 가려는 부분
*/

// num은 int 변수입니다. 3이 담겨 있습니다.
int num = 3;


// arr은 int 다섯 칸짜리 배열입니다.
// - 프로그래머가 적어 둔 initializer 부분을 토대로
//   C 컴파일러는 arr에 대한 정의에 필요한 '칸 수' 정보를 유추해요
// - 이름 arr에 마우스 갖다 대면 진짜 그러고 있다는 것을 확인할 수 있어요
int arr[] = { 3, 5, 7, 11, 13 };


// ptr은 int 포인터 변수입니다. 0이 담겨 있습니다.
// - 보편적인 C 컴파일러들은 절대로 어떤 이름에 대한 위치 값을 0으로 정의하지 않고,
//   보편적인 컴퓨터들/운영체제들은 메모리 맨 앞 영역(위치 값이 매우 작은 영역)에 특별한 의미를 부여해 다루어요
// - 따라서 아래 선언은 포인터 변수 ptr을 '유효한 칸에 대한 위치 값이 담겨 있지 않음' 상태로 두는 게 돼요
//   어떤 환경에서는 0 말고 다른 무언가를 써서 이러한 목표를 달성하기도 해요. 이 부분은 지금은 그냥 그러려니 해도 될 듯 해요
int *ptr = 0;



// 예시 코드들을 조금씩 나누어 실행하기 위해 여러 함수들로 구성해 두었어요
void func1();
void func2();
void func3();
void func4();
void func5();
void func6();



int main()
{
	// 시작: 각 이름들에 대해 정의된 위치 값들 살펴보기
	printf("위치 값들:\n"
		   "&num: %p\n"
		   "&arr: %p\n"
		   "&ptr: %p\n"
		   "--> 모두 각자 다른 위치에 잘 정의되어 있음.\n\n", &num, &arr, &ptr);

	// TODO: 아래의 함수 호출식(이 적힌 문장)들을 하나씩 주석 풀어서 함수 정의 내용을 구경한 다음 실행해 보세요.
	//       실행 결과를 띄워 놓고 코드 내용과 비교하며 함수 정의 안에 적어 둔 주석 설명도 읽어 보세요.
	//       (번호 순서대로 ㄱㄱ하면 조금 더 이해하기 쉬울 듯!)

	func1();
	//func2();
	//func3();
	//func4();
	//func5();
	//func6();

	return 0;
}



void func1()
{
	// 1. 포인터 변수 이름을 써서 다른 변수에 대해 정의된 한 칸 사용하기
	//    - 이전에 살펴 본 내용을 복습해요
	//    - & 연산자와 * 연산자 사이의 대칭성?을 확인해 봐요
	ptr = &num;

	printf("ptr = &num 이후:\n"
		   "&num: %p\n"
		   " ptr: %p\n"
		   " num: %d\n"
		   "*ptr: %d\n"
		   "--> 두 수식 쌍은 실질적으로 같은 형식 같은 값이 나옴.\n\n", &num, ptr, num, *ptr);


	printf("다시 살펴 보면...\n"
		   "  num: %8d |   *ptr: %8d\n"
		   " &num: %8p |  &*ptr: %8p\n"
		   "*&num: %8d | *&*ptr: %8d\n"
		   "--> 큰 수식 *&exp가 유효하다면 이는 수식 exp와 동일해 보임.\n\n", num, *ptr, &num, &*ptr, *&num, *&*ptr);


	*ptr = 5;

	printf("*ptr = 5 이후:\n"
		   " &num: %p\n"
		   "  ptr: %p\n"
		   "*&num: %d\n"
		   "* ptr: %d\n"
		   "  num: %d\n"
		   "* ptr: %d\n"
		   "--> 둘 둘 둘 단위로 끊어서 보면 당연히 이렇게 나와야 함.\n"
		   "    - 첫 둘은 할당식 ptr = &num에 의해 성립(좌항/우항 형식도 동일)\n"
		   "    - 다음 둘은 첫 둘에 * 연산자 붙인 것\n"
		   "    - 마지막 둘은 뭐 이미 알고 있던 것\n", &num, ptr, *&num, *ptr, num, *ptr);

	/*
		& 연산자와 * 연산자 정리:
		
		수식 exp가 T 형식 lvalue 수식일 때...

		1. 수식 exp에 & 연산자를 붙인 수식 &exp의 형식은 T *이 됩니다.
			- int     -> int *
			- int *   -> int **
			- int [3] -> int (*)[3]
			- int ()  -> int (*)()
		
		2. 수식 *&exp는 수식 exp와 형식 및 계산 결과가 동일합니다.
			- T 형식 lvalue 수식에 & 연산자를 붙이면 T * 형식 수식이 되니 그 수식에 * 연산자를 붙이는 것은 늘 가능

		3. & 연산자는 기본적으로 '위치 값'을 얻기 위한 연산자므로
		   & 연산자가 마지막에 붙는 수식은 절대 lvalue 수식이 될 수 없습니다.
		    - 수식 &&exp는 원래 수식 exp가 뭐였든 무조건 유효하지 않아요
	*/
}




void func2()
{
	// 2. 포인터 변수로 다른 '배열'에 대해 정의된 한 칸 사용하기
	//    - 이것도 복습이에요
	ptr = &arr[1];

	printf("ptr = &arr[1] 이후:\n"
		   "&arr[1]: %p\n"
		   " ptr   : %p\n"
		   " arr[1]: %d\n"
		   "*ptr   : %d\n\n", &arr[1], ptr, arr[1], *ptr);

	*ptr = 3;
	printf("*ptr = 3 이후:\n"
		   "&arr[1]: %p\n"
		   " ptr   : %p\n"
		   " arr[1]: %d\n"
		   "*ptr   : %d\n\n", &arr[1], ptr, arr[1], *ptr);

	/*
		수식 &arr[1]을 살짝 뜯어서 각 부분 수식의 형식을 확인해 보면...

		 arr   : int [5]
		 arr[1]: int
		&arr[1]: int *

		...이 됩니다.
		
		보면 알 수 있듯, 수식 &arr[1]과 수식 ptr의 형식이 동일하므로
		할당식 ptr = &arr[1] 계산 이후에 이 두 수식을 동일한 느낌으로 사용할 수 있게 됩니다.
		(물론 &ptr은 되지만 &&arr[1]은 안 되긴 해요)

		그렇다 보니 수식 *ptr과 수식 *&arr[1] -> arr[1]이 계산 결과값이 동일한 게 당연한 듯 해요
	*/
}


void func3()
{
	// 3. 배열의 각 칸 사이의 관계 살펴 보기
	//    - 배열 이름을 수식으로서 적었을 때 이를 어떻게 간주해 주는지 확인해요
	printf("arr의 각 칸에 대한 포인터 값들:\n"
		   "&arr[0]: %p\n"
		   "&arr[1]: %p\n"
		   "&arr[2]: %p\n"
		   "&arr[3]: %p\n"
		   "&arr[4]: %p\n", &arr[0], &arr[1], &arr[2], &arr[3], &arr[4]);

	printf("--> 각 칸들의 위치 값 차이는 %d고, 이는 sizeof(int)와 같음.\n\n", (int)sizeof(int));


	printf("그리고...\n"
		   "&arr   : %p\n"
		   "&arr[0]: %p\n"
		   "...이 둘은 동일한 값이 나옴 --> 배열의 위치 == 배열의 0번째 칸의 위치\n\n", &arr, &arr[0]);

	printf("마지막으로...\n"
		   " arr: %p\n"
		   "&arr: %p\n"
		   "...이 둘 역시 동일한 값이 나옴.( func3()에 있는 주석 참조 )\n\n", arr, &arr);

	/*
		원래 변수들은 number와 &number의 계산 결과값이 달랐습니다.
		왜냐면, 우리가 변수 이름을 가지고 이 두 가지 값을 모두 얻을 수 있기 때문이었지요.

		그러나 배열은 변수가 아니므로, 원칙적으로 배열 이름'만'으로는 값을 얻기 위한 '한 칸'을 특정할 수 없습니다.
		따라서, 우리가 그냥 arr이라고 적어 놓아도,
		컴파일러는 알아서 2순위에 해당하는 'arr이 정의된 위치 값'이 계산되도록 간주해 줍니다.
		
		여기서 좀 더 정밀하게 말하면, 수식으로서 적은 배열의 이름은, & 연산자가 바로 붙지 않았다면,
		그 배열의 0번째 칸을 가리키는 '포인터 상수' 수식으로 deduce됩니다.
		- 일단 'arr이 정의된 위치 값'과 'arr의 0번째 칸에 대한 위치 값'은 늘 동일해요.
		- 그렇기는 하지만 수식 arr과 &arr이 '동일한 포인터 형식 값'이 나오는 것은 아니에요.
		  전자는 여전히 int [5] 형식이고 후자는 이제 int (*)[5] 형식이 되어요.
	*/

	// 아래 문장에 중단점을 찍고 x86 모드로 바꾸고 F5 누른 다음 디스어셈블리 탭을 열어 보면
	// '배열 arr에 대해 정의된 위치 값'이 진짜 즉시값이 되어 들어 있는 것을 볼 수 있을 거예요.
	// (엄밀히 말하면 이는 배열 arr이 static 위치를 갖기 때문에 그렇기는 해요. 이 부분은 좀 더 뒤에 다시 나올 듯)
	ptr = arr;
}


void func4()
{
	// 4. 배열 이름을 포인터 상수 값 나오는 수식처럼 사용하기
	//    - 배열 이름이 다른 연산자와 함께 사용될 때 어떻게 deduce될 수 있는지 확인해요
	printf("0번째 칸 가지고 놀기:\n"
		   "  arr   : %p\n"
		   " &arr[0]: %p\n"
		   "* arr   : %d\n"
		   "*&arr[0]: %d\n"
		   "  arr[0]: %d\n\n", arr, &arr[0], *arr, *&arr[0], arr[0]);

	printf("1번째 칸 가지고 놀기:\n"
		   "   arr + 1 : %p\n"
		   " & arr[1]  : %p\n"
		   "* (arr + 1): %d\n"
		   "*& arr[1]  : %d\n"
		   "   arr[1]  : %d\n"
		   "결론: 수식 arr[n]은 수식 *(arr + n)과 동일함\n"
		   "--> \'배열의 n번째 칸\'은 \'배열 이름(포인터 상수)보다 n칸만큼 뒤에 있는 칸\'임!\n\n", arr + 1, &arr[1], *(arr + 1), *&arr[1], arr[1]);

	/*
		Deduce를 전제하지 않는 & 연산자와 다르게 * 연산자는 필요한 경우 대상 수식을 deduce해요.
		(& 연산자와 sizeof 연산자는 일단 지금은 좀 특별한 친구들이라고 생각하면 좋을 듯 해요)

		엄밀히 말하면 수식 *arr이나 arr + 1은 이름 arr을 '선언해 둔 대로 사용'하지 않는 수식이에요.
		이 때 C 컴파일러는 미리 정해 둔 규칙에 따라 이 수식을 *(int *)arr, (int *)arr + 1과 같이 컴파일되도록 deduce해요.
			- 사실 printf() 인수 자리에 수식 arr을 적을 때도 이 규칙이 동일하게 적용되긴 해요.


		C에서 * 연산자와 [ ] 연산자는 매우 밀접한 관계를 가지고 있어요.
		이러한 사실을 토대로 다음 예시 함수들의 내용을 좀 더 진솔하게 납득할 수 있을 거예요.
	*/
}


void func5()
{
	// 4. 포인터 변수 이름을 배열 이름처럼 사용하기
	ptr = arr;

	printf("ptr = arr 이후:\n"
		   " ptr: %p\n"
		   " arr: %p\n"
		   "&ptr: %p\n"
		   "&arr: %p\n\n", ptr, arr, &ptr, &arr);

	printf("0번째 칸 가지고 놀기:\n"
		   "  ptr   : %p\n"
		   " &ptr[0]: %p\n"
		   "* ptr   : %d\n"
		   "*&ptr[0]: %d\n"
		   "  ptr[0]: %d\n\n", ptr, &ptr[0], *ptr, *&ptr[0], ptr[0]);

	printf("1번째 칸 가지고 놀기:\n"
		   "   ptr + 1 : %p\n"
		   " & ptr[1]  : %p\n"
		   "* (ptr + 1): %d\n"
		   "*& ptr[1]  : %d\n"
		   "   ptr[1]  : %d\n"
		   "결론: \'포인터 변수에 담긴 값\'을 마치 배열 이름에 대해 정의된 값처럼 사용할 수 있음.\n"
		   "      ( func5()에 있는 주석 참조 )\n\n", ptr + 1, &ptr[1], *(ptr + 1), *&ptr[1], ptr[1]);

	/*
		포인터 변수의 경우 '변수'기 때문에 ptr 값(변수 자체에 담긴 값)과 &ptr 값(그 값을 담기 위해 정의된 위치 값)이 서로 다릅니다.
		그러나 위의 복잡한 수식들 중 &ptr 값을 사용하는 수식은 현재 하나도 없지요.

		수식 ptr = arr을 장황하게 풀면,
		'포인터 변수 ptr에 배열 arr의 0번째 칸에 대한 위치 값을 담는다'가 됩니다.
		= 연산자의 좌항에 의해 수식 ptr = (int *)arr과 같이 deduce돼요.

		이렇게 되면 수식 ptr과 수식 arr의 계산 결과값이 동일해지므로,
		두 수식을 (비록 형식은 달라도) 동일한 칸을 다루기 위해 사용할 수 있게 됩니다.
		--> C의 [] 연산자도 이게 가능하도록 잘 만들어져 있어요.
	*/
}


void func6()
{
	int *Choice(int[]);

	printf("Chosen number is %d\n", *Choice(arr));
}

int *Choice(int numbers[])
{
	printf("in Choice():\n"
		   "(global) arr    : %p\n"
		   "(local ) numbers: %p\n"
		   "(global)&arr    : %p\n"
		   "(local )&numbers: %p\n"
		   "--> ( 파일 맨 아래 Choice()에 있는 주석 참조 )\n\n", arr, numbers, &arr, &numbers);

	/*
		C 컴파일러는 이러한 C의 배열-포인터 관계를 우리보다 훨씬 더 잘 알고 있습니다.
		따라서, 지금처럼,
		프로그래머가 '변수'의 일종인 '인수' numbers를 통해 '변수'가 아닌 '배열'을 전달하도록 코드를 작성했을 때,
		'배열이 변수에 들어가냐? 멍청아' 하면서 빨간 줄을 그어버리는 것이 아니라
		그 배열 형식과 호환되는 포인터 형식으로 자동으로 알아듣고 컴파일해 줍니다!

		--> int* Choice(int *numbers)로 간주해 줍니다.
		    이 함수 정의 안에 적어 둔 수식 numbers에 마우스를 갖다 대 보면 진짜 그러고 있는 것을 볼 수 있어요

		--> 그리고, 어차피 컴파일러가 이렇게 간주할 것이기 때문에
			함수의 인수로서 배열을 선언할 때는 굳이 numbers[5]처럼 숫자를 넣어 주지 않아도 됩니다.
			(이거 거짓말이긴 한데 아무튼 지금 이 함수는 그래요)

			어차피 내가 적어 놓아봤자 무시해버리고 '포인터 한 칸짜리'로 정의해 줄 것이기 때문입니다!
			(이건 맞아요)
	*/

	return numbers;
}