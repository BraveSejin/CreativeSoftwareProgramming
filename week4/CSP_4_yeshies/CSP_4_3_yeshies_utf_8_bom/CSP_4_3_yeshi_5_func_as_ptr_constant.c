/*
	'수식으로써 적은' 포인터 변수, 배열, 함수 이름이
	C 컴파일러에 의해 어떻게 deduce될 수 있는지 확인하기 위한 예시들이에요.

	이 파일에서는
	수식으로서 적은 함수 이름이
	해당 함수에 대해 정의된 포인터 상수 값이 나오는 수식으로 deduce될 수 있음을 확인해 봐요.
*/
 
#include <stdio.h>

// thr()은 인수는 신경 안 쓰고 int 값 하나를 던져 주는 함수입니다. 여기서 정의까지 다 해 놓았지요.
int thr()
{
	return 3;
}

// fiv()'도', 인수는 신경 안 쓰고 int 값 하나를 던져 주는 함수입니다. 여기서 정의까지 다 해 놓았지요.
int fiv()
{
	return 5;
}

/*
	ptr을 선언 읽는 순서에 따라 읽으면...
		포인터 변수인데, 따라가면...
			인수는 모르겠고 아무튼 함수가 있고, 이걸 호출하면...
				int 값 하나를 return받게 됩니다.

	아무튼 ptr은 포인터 변수고, 지금은 0이 담겨 있습니다.
*/
int (*ptr)() = 0;



void func1(), func2(), func3();

int main()
{
	// 시작: 각각 정의된 위치 값들 살펴보기
	printf("위치 값들:\n"
		   "&thr: %p\n"
		   "&fiv: %p\n"
		   "&ptr: %p\n"
		   "--> 모두 각자 다른 위치에 잘 정의되어 있음.\n\n", &thr, &fiv, &ptr);

	// TODO: 아래의 함수 호출식(이 적힌 문장)들을 하나씩 주석 풀어서 함수 정의 내용을 구경한 다음 실행해 보세요.
	//       실행 결과를 띄워 놓고 코드 내용과 비교하며 함수 정의 안에 적어 둔 주석 설명도 읽어 보세요.
	//       (번호 순서대로 ㄱㄱ하면 조금 더 이해하기 쉬울 듯!)

	func1();
	//func2();

	// 주의: 마지막 함수는 주석 푼 다음 아래에 있는 함수 정의를 먼저 읽어 보세요.
	//func3();

	return 0;
}

void func1()
{
	// 1. 포인터 변수로 다른 (곳에 정의된) 함수 사용하기
	ptr = &thr;

	printf("ptr = &thr 이후:\n"
		   "&thr: %p\n"
		   " ptr: %p\n"
		   " thr: %p\n"
		   "*ptr: %p\n\n", &thr, ptr, thr, *ptr);

	printf("이걸 실제로 호출하면...\n"
		   "(&thr)(): %d\n"
		   "  ptr (): %d\n"
		   "  thr (): %d\n"
		   "(*ptr)(): %d\n"
		   "--> ( func1()에 있는 주석 참조 )\n\n", (&thr)(), ptr(), thr(), (*ptr)());

	/*
		여기까지 왔으면 대충 짐작할 수 있을 것입니다.
		첫 출력에서 네 가지 수식이 우리에게 주는 값은 '모두' 동일합니다.
		그리고 그 값은 실제 thr()이 정의되어 있는 위치 값입니다.

		따라서, 우리는 그 값을 사용함으로써 thr()을 실제로 호출할 수 있습니다.
		C에서 함수를 호출한다는 것은, '내 손에 있는 이 위치 값을 따라가면 나오는 그 함수를 호출'을 의미하기 때문입니다.
		- 물론 수식 ptr()과 수식 thr()은 서로 다른 명령어를 써서 구성되긴 해요. thr()은 '늘 동일한 static 위치를 갖는 그 함수를 호출'이라 그래요.

		1번 예제에서 본 배열의 경우와 마찬가지로,
		함수 또한 '이름만 가지고는 한 칸이 특정되지 않기에' thr과 &thr 값이 동일한 듯 합니다.
	*/
}


void func2()
{
	printf("  fiv: %p\n"
		   " *fiv: %p\n"
		   "**fiv: %p\n"
		   "****************fiv: %p\n"
		   "&*&**&***&****&*fiv: %p\n\n", fiv, *fiv, **fiv, ****************fiv, &*&**&***&****&*fiv);

	printf("   fiv (): %d\n"
		   " (*fiv)(): %d\n"
		   "(**fiv)(): %d\n"
		   "(****************fiv)(): %d\n"
		   "(&*&**&***&****&*fiv)(): %d\n"
		   "--> ( func2()에 있는 주석 참조 )\n\n", fiv(), ( *fiv )( ), ( **fiv )( ), ( ****************fiv )( ), ( &*&**&***&****&*fiv )());

	/*
		배열의 경우는,
		여러 칸들 중 0번째 칸만 가리키도록 간주했기 때문에
		배열의 이름은 0번째 칸 '하나'에 대한 포인터 상수라고 생각할 수 있습니다.
		그래서 배열 이름에 *를 붙이면, '그 배열 자체'가 아닌 '그냥 0번째 칸에 들어 있는 값'이 나오지요.

		함수는 그렇지 않습니다.
		우리가 함수를 호출한다는 것은 언제나 '그 함수에 대한 가장 첫 명령어부터 순차적으로 실행'을 상정합니다.
		('순차' 규칙을 생각하면 당연히 그래야 해요!)
		그렇기 때문에, *fiv를 해서 '이름 fiv가 가리키는 곳에 있는 것'을 꺼내도, 그 결과는 여전히 '함수 fiv의 첫 명령어', 즉, '함수 fiv 그 자체'라 말할 수 있습니다.
		--> 수식 fiv와 *fiv는 언제나 '함수 fiv'를 특정합니다.
		
		그러다 보니 위 예시처럼 변태같이 연산자를 길게 늘여 놓아도 결국 계산 결과는 상수인 '함수 fiv' 또는 그 위치 값이 됩니다.
		--> 둘의 차이는 lvalue 관점에서 본다면 조금 다르긴 한데, 일단 지금은 그리 중요하지는 않아요.
		    (fiv이나 &fiv은 되지만 &&fiv은 안 됨!)
	*/
}


void func3()
{
	int new_thr(int);

	int(*new_ptr)( int );


	// ptr의 형식은 int (*)()입니다.
	// 그런데 int (*)(int) 형식 값을 담고 있어요!
	ptr = new_thr;

	// TODO: 아래에 주석으로 되어 있는 세 줄을 실제로 실행하면 어떻게 될 지 상상해 봅시다.
	//       그리고 직접 그 결과를 확인해 보세요.
	printf("ptr = new_thr 이후:\n");
	//printf("ptr()       : %d\n", ptr());
	//printf("ptr(10)     : %d\n", ptr(10));
	//printf("ptr(\"HELLO\"): %d\n", ptr("HELLO"));
	printf("\n");



	// new_ptr의 형식은 int (*)(int)입니다.
	// 그런데 void (*)() 형식 값을 담고 있어요!
	new_ptr = func1;

	// TODO: 아래에 주석으로 되어 있는 세 줄을 실제로 실행하면 어떻게 될 지 상상해 봅시다.
	//       그리고 직접 그 결과를 확인해 보세요. (오류 날 지도 모름!)
	printf("new_ptr = func1 이후:\n");
	//new_ptr();
	//new_ptr(10);
	//new_ptr("HELLO");
	printf("\n--> ( func3()에 있는 주석 참조 )\n\n");


	/*
		조금 요상한 예시긴 하지만, C가 가진 기본적인 원칙을 잘 관찰할 수 있습니다.

		C 컴파일러는 자기가 생각하기에 영 말이 안 되는 코드는 그냥 빨간 줄 긋고 컴파일을 안 해 버립니다.
		그리고 그 기준은, 지난주에 슬쩍 봤듯, 프로그래머가 적어 둔 선언에 둡니다.

		위 예시의 주석으로 된 여섯 줄 중 유일하게 빨간 줄이 그어지는 부분은,
		명백히 인수 하나 받으라고 선언에 적혀 있음에도 불구하고 인수 없이 포인터 변수에 담아 둔 위치의 함수를 실행하는 부분입니다.

		이건 그렇다 치고, 그러면 왜 다른 부분에서는 오류가 안 나는 것일까요?
		이 부분은 지금은 조금 어려우니 궁금하면 따로 물어보면 좋겠습니다.

		일단 지금은,
		내가 선언해 둔 대로 사용하지 않으면 잘 실행되지 않을 수도 있다.
		(보통은 컴파일러가 막지만, 그렇지 않을 때도 있다)
		...정도만 느끼고 넘어가도록 합시다.
	*/
}

int new_thr(int number)
{
	return number;
}